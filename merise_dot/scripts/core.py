from .constraints import *
from .table import SQLTable, TableField, TableFieldType

# Constants. Please do not touch
_HEADER = "-- Generated by merise_dot"


class SQLConversionKernel:
    """Core of the MLD to SQL conversion process.
    This will ensure flexibility for the conversion process, but it won't perform
    any writing on its own.
    """

    def __init__(self) -> None:
        if type(self) == SQLConversionKernel:
            exit(-1) # this is abstract
        self._current_table: SQLTable = None
        self._tables: list[SQLTable] = []
        self._constraints: dict[str | Constraint] = {}
        self._name: str = ""

    def db_name(self, name: str) -> None:
        self._name = name if not self._name else self._name

    def mk_table(self, name: str) -> None:
        """Add a new table to write into into the script.

        :param name: The table's name. Must be unique.
        """
        table: SQLTable = SQLTable(name)
        self._tables.append(table)
        self._current_table = table

    def get_table(self,name:str)->SQLTable:
        for t in self._tables:
            if t._name==name:
                return t
        raise Exception(f"table {name} not found")

    def close_table(self) -> None:
        """Close the table we're writing into.
        """
        self._current_table = None

    def check_field_type(self, f_type: str) -> TableFieldType:
        """Turns the given field type into a valid SQL type.
        Please keep in mind that in case of wrongful type, this should raise an
        exception to avoid further problems.

        :param f_type: the type to check
        :return: the valid SQL type, if any
        """
        raise Exception("this core cannot parse types")

    def mk_field(
            self,
            name: str,
            f_type: str,
            nullable: bool = True,
            pk: bool = False) -> None:
        """Add a field into the current table we're editing.

        :param name: The field's name.
        :param f_type: The field's type (pre-check)
        :param nullable: Wether the field can be null or not.
        """
        if not self._current_table:
            raise Exception("You are not editing a table")
        field = TableField(name, self.check_field_type(f_type))
        if pk:
            field.pk()
        self._current_table.add_field(field)

    def mk_constraint(self, cstr: Constraint) -> None:
        """Define a constraint for the table we're editing.

        :param cstr: The constraint builder to check the definition of said
        constraint.
        """
        if cstr._name in self._constraints.keys():
            raise Exception("Existing constraint")
        self._constraints[cstr._name] = cstr

    def __str__(self) -> str:
        drop = f"drop database {self._name};\n\ncreate database {self._name};"
        # adding table conversion and constraints
        tablestr: str = f"{"\n\n".join(str(table) for table in self._tables)}"
        cststr: str = f""
        # assembling sections
        text = f"{drop}{f"\n\n{tablestr}" if tablestr else ""}"
        # assembling all text
        return f"{_HEADER}\n\n{text}"
